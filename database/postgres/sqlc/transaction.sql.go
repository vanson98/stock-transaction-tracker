// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transaction.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(T.id)
FROM investments AS I
INNER JOIN transactions AS T ON I.id = T.investment_id
WHERE I.account_id = $1 AND
 	  T.ticker LIKE 
	  	CASE WHEN $2::text = '' THEN '%%' ELSE $2::text END
`

type CountTransactionsParams struct {
	AccountID int64  `json:"account_id"`
	Ticker    string `json:"ticker"`
}

func (q *Queries) CountTransactions(ctx context.Context, arg CountTransactionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactions, arg.AccountID, arg.Ticker)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions(investment_id,ticker,trading_date,trade,volume,order_price,match_volume,match_price,match_value,fee,tax,"cost","cost_of_goods_sold","return","status")
VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15)
RETURNING id, investment_id, ticker, trading_date, trade, volume, order_price, match_volume, match_price, match_value, fee, tax, cost, cost_of_goods_sold, return, status
`

type CreateTransactionParams struct {
	InvestmentID    int64             `json:"investment_id"`
	Ticker          string            `json:"ticker"`
	TradingDate     pgtype.Timestamp  `json:"trading_date"`
	Trade           TradeType         `json:"trade"`
	Volume          int64             `json:"volume"`
	OrderPrice      int64             `json:"order_price"`
	MatchVolume     int64             `json:"match_volume"`
	MatchPrice      int64             `json:"match_price"`
	MatchValue      int64             `json:"match_value"`
	Fee             int64             `json:"fee"`
	Tax             int64             `json:"tax"`
	Cost            int64             `json:"cost"`
	CostOfGoodsSold int64             `json:"cost_of_goods_sold"`
	Return          int64             `json:"return"`
	Status          TransactionStatus `json:"status"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.InvestmentID,
		arg.Ticker,
		arg.TradingDate,
		arg.Trade,
		arg.Volume,
		arg.OrderPrice,
		arg.MatchVolume,
		arg.MatchPrice,
		arg.MatchValue,
		arg.Fee,
		arg.Tax,
		arg.Cost,
		arg.CostOfGoodsSold,
		arg.Return,
		arg.Status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.InvestmentID,
		&i.Ticker,
		&i.TradingDate,
		&i.Trade,
		&i.Volume,
		&i.OrderPrice,
		&i.MatchVolume,
		&i.MatchPrice,
		&i.MatchValue,
		&i.Fee,
		&i.Tax,
		&i.Cost,
		&i.CostOfGoodsSold,
		&i.Return,
		&i.Status,
	)
	return i, err
}

const getTransactionById = `-- name: GetTransactionById :one
select id, investment_id, ticker, trading_date, trade, volume, order_price, match_volume, match_price, match_value, fee, tax, cost, cost_of_goods_sold, return, status from transactions
where id = $1
`

func (q *Queries) GetTransactionById(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionById, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.InvestmentID,
		&i.Ticker,
		&i.TradingDate,
		&i.Trade,
		&i.Volume,
		&i.OrderPrice,
		&i.MatchVolume,
		&i.MatchPrice,
		&i.MatchValue,
		&i.Fee,
		&i.Tax,
		&i.Cost,
		&i.CostOfGoodsSold,
		&i.Return,
		&i.Status,
	)
	return i, err
}

const getTransactionsPaging = `-- name: GetTransactionsPaging :many
SELECT T.id, to_char(T.trading_date,'dd/mm/yyyy') as trading_date, T.ticker, T.trade, T.volume, T.order_price, T.match_volume, T.match_price, T.match_value, T.fee, T.tax, T."cost", T.cost_of_goods_sold, T."return", T.status
FROM investments AS I
INNER JOIN transactions AS T ON I.id = T.investment_id
WHERE I.account_id = $1 AND
 	  T.ticker LIKE 
	  	CASE WHEN $2::text = '' THEN '%%' ELSE $2::text END
ORDER BY 
	CASE WHEN $3::text = 'trading_date' AND $4::text = 'descending' THEN T.trading_date END DESC,
	CASE WHEN $3::text = 'cost_of_goods_sold' AND $4::text = 'descending' THEN T.cost_of_goods_sold END DESC,
	CASE WHEN $3::text = 'return' AND $4::text = 'descending' THEN T.return END DESC,
	CASE WHEN $3::text = 'trading_date' AND $4::text = 'ascending' THEN T.trading_date END ASC,
	CASE WHEN $3::text = 'cost_of_goods_sold' AND $4::text = 'ascending' THEN T.cost_of_goods_sold END ASC,
	CASE WHEN $3::text= 'return' AND $4::text = 'ascending' THEN T.return END ASC
OFFSET $5::int LIMIT $6::int
`

type GetTransactionsPagingParams struct {
	AccountID  int64  `json:"account_id"`
	Ticker     string `json:"ticker"`
	OrderBy    string `json:"order_by"`
	OrderType  string `json:"order_type"`
	FromOffset int32  `json:"from_offset"`
	ToLimit    int32  `json:"to_limit"`
}

type GetTransactionsPagingRow struct {
	ID              int64             `json:"id"`
	TradingDate     string            `json:"trading_date"`
	Ticker          string            `json:"ticker"`
	Trade           TradeType         `json:"trade"`
	Volume          int64             `json:"volume"`
	OrderPrice      int64             `json:"order_price"`
	MatchVolume     int64             `json:"match_volume"`
	MatchPrice      int64             `json:"match_price"`
	MatchValue      int64             `json:"match_value"`
	Fee             int64             `json:"fee"`
	Tax             int64             `json:"tax"`
	Cost            int64             `json:"cost"`
	CostOfGoodsSold int64             `json:"cost_of_goods_sold"`
	Return          int64             `json:"return"`
	Status          TransactionStatus `json:"status"`
}

func (q *Queries) GetTransactionsPaging(ctx context.Context, arg GetTransactionsPagingParams) ([]GetTransactionsPagingRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsPaging,
		arg.AccountID,
		arg.Ticker,
		arg.OrderBy,
		arg.OrderType,
		arg.FromOffset,
		arg.ToLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsPagingRow
	for rows.Next() {
		var i GetTransactionsPagingRow
		if err := rows.Scan(
			&i.ID,
			&i.TradingDate,
			&i.Ticker,
			&i.Trade,
			&i.Volume,
			&i.OrderPrice,
			&i.MatchVolume,
			&i.MatchPrice,
			&i.MatchValue,
			&i.Fee,
			&i.Tax,
			&i.Cost,
			&i.CostOfGoodsSold,
			&i.Return,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
