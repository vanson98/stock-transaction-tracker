// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transaction.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions(investment_id,ticker,trading_date,trade,volume,order_price,match_volume,match_price,match_value,fee,tax,"cost","cost_of_goods_sold","return","status")
VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15)
RETURNING id, investment_id, ticker, trading_date, trade, volume, order_price, match_volume, match_price, match_value, fee, tax, cost, cost_of_goods_sold, return, status
`

type CreateTransactionParams struct {
	InvestmentID    int64             `json:"investment_id"`
	Ticker          string            `json:"ticker"`
	TradingDate     pgtype.Timestamp  `json:"trading_date"`
	Trade           TradeType         `json:"trade"`
	Volume          int64             `json:"volume"`
	OrderPrice      int64             `json:"order_price"`
	MatchVolume     int64             `json:"match_volume"`
	MatchPrice      int64             `json:"match_price"`
	MatchValue      int64             `json:"match_value"`
	Fee             int64             `json:"fee"`
	Tax             int64             `json:"tax"`
	Cost            int64             `json:"cost"`
	CostOfGoodsSold int64             `json:"cost_of_goods_sold"`
	Return          int64             `json:"return"`
	Status          TransactionStatus `json:"status"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.InvestmentID,
		arg.Ticker,
		arg.TradingDate,
		arg.Trade,
		arg.Volume,
		arg.OrderPrice,
		arg.MatchVolume,
		arg.MatchPrice,
		arg.MatchValue,
		arg.Fee,
		arg.Tax,
		arg.Cost,
		arg.CostOfGoodsSold,
		arg.Return,
		arg.Status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.InvestmentID,
		&i.Ticker,
		&i.TradingDate,
		&i.Trade,
		&i.Volume,
		&i.OrderPrice,
		&i.MatchVolume,
		&i.MatchPrice,
		&i.MatchValue,
		&i.Fee,
		&i.Tax,
		&i.Cost,
		&i.CostOfGoodsSold,
		&i.Return,
		&i.Status,
	)
	return i, err
}

const getTransactionById = `-- name: GetTransactionById :one
select id, investment_id, ticker, trading_date, trade, volume, order_price, match_volume, match_price, match_value, fee, tax, cost, cost_of_goods_sold, return, status from transactions
where id = $1
`

func (q *Queries) GetTransactionById(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionById, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.InvestmentID,
		&i.Ticker,
		&i.TradingDate,
		&i.Trade,
		&i.Volume,
		&i.OrderPrice,
		&i.MatchVolume,
		&i.MatchPrice,
		&i.MatchValue,
		&i.Fee,
		&i.Tax,
		&i.Cost,
		&i.CostOfGoodsSold,
		&i.Return,
		&i.Status,
	)
	return i, err
}

const getTransactionsPaging = `-- name: GetTransactionsPaging :many
SELECT id, investment_id, ticker, trading_date, trade, volume, order_price, match_volume, match_price, match_value, fee, tax, cost, cost_of_goods_sold, return, status FROM transactions
WHERE ticker LIKE
	CASE WHEN $1::text <> '' THEN $1::text ELSE '%%' END
ORDER BY trading_date DESC
OFFSET 0 LIMIT 10
`

func (q *Queries) GetTransactionsPaging(ctx context.Context, ticker string) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsPaging, ticker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.InvestmentID,
			&i.Ticker,
			&i.TradingDate,
			&i.Trade,
			&i.Volume,
			&i.OrderPrice,
			&i.MatchVolume,
			&i.MatchPrice,
			&i.MatchValue,
			&i.Fee,
			&i.Tax,
			&i.Cost,
			&i.CostOfGoodsSold,
			&i.Return,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
